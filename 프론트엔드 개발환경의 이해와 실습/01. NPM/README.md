# 01. NPM

## 참고

본 글은 인프런의 [프론트엔드 개발환경의 이해와 실습](https://www.inflearn.com/course/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD#) 강의 및 강사 분의 블로그 글 [프론트엔드 개발환경의 이해: NPM](https://jeonghwan-kim.github.io/series/2019/12/09/frontend-dev-env-npm.html)을 바탕으로 작성한 것입니다.

## Node.js 필요성

### 1. 최신 스펙 개발

자바스크립트 스펙의 발전과 비교했을 때 웹 브라우저의 발전 속도는 느릴 수밖에 없다. 따라서 이를 연결해주는 바벨(Babel) 등의 도구를 활용해야 하는데 웹팩(WebPack), NPM(Node Package Manager)과 같은 노드(Node) 기술로 만들어진 환경에서 해당 도구를 사용해야 자동화된 웹 개발 환경을 갖출 수 있다.

더욱이 타입스크립트 등과 같은 자바스크립트 위에서 작동하는 고수준 언어를 사용하기 위해서는 전용 트랜스파일러 또한 필요하기 때문에 이를 실행하는 노드 환경에 대해 이해하는 건 중요하다.

여기서 트랜스파일러(Transpiler)란 같은 언어를 문법적으로 변환해주는 도구를 의미한다. 다시 말해 타입스크립트로 작성한 문법을 자바스크립트로 변경해주고, 바벨을 틍해 ES6 이후의 자바스크립트 문법을 ES5로 변환해주는 등의 역할을 해주는 것이다.

### 2. 빌드 자동화

브라우저에 보통 난독화된 소스 코드가 실행되거나 앞서 바벨 등을 거쳐 폴리필(Polyfill)이 추가된다. 노드는 이러한 복잡한 작업에 대해 빌드를 자동화해 줄 뿐만 아니라 라이브러리 의존성 해결과 더불어 테스트 또한 자동화해준다.

여기서 폴리필이란 자바스크립트의 최신 스펙과 웹 브라우저의 지원 사항이 일치하지 않아 발생하는 오류를 극복하기 위해 웹 브라우저에서 지원하지 않는 코드를 사용 가능한 코드로 변환해주는 걸 의미한다.

### 3. 사용자화

CRA(Create React App) 등을 활용하여 각 프레임워크에 대한 개발환경을 손쉽게 구축할 수 있지만 현실적으로 사용자화(Customize)가 필요할 때가 더러 있기 마련이다. 이럴 때 노드에 대한 배경지식을 바탕으로 필요한 부분을 수정할 수 있어야 한다.

## package.json

### 초기화

`npm init` 명령문을 통해 최초의 [package.json](./package.json) 파일을 생성할 수 있다.

```JSON
{
  "name": "01. NPM",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC"
}
```

이후 해당 파일에 `npm` 명령어를 활용하여 여러 라이브러리를 설치하거나 자동화할 스크립트를 관리하게 된다.

### 명령어

`npm` 명령어를 터미널에 입력하면 `npm` 명령어를 토대로 사용할 수 있는 많은 추가 명령어가 나열된다. 그 중 가장 많이 사용되는 것들 중 하나는 아래와 같다.

- `start`: 애플리케이션 실행을 의미한다.
- `test`: 애플리케이션에 대한 테스트를 의미한다.
- `install`: 패키지 설치를 의미한다.
- `uninstall`: 패키지 삭제를 의미한다.

아래와 같이 [package.json](./package.json) 파일을 관리해서 `npm` 명령어(Script)를 만들어 쓸 수 있는데 이를 테면 `build` 부분과 같다. 이때 유의할 점은 `npm build` 명령문이 아닌 `npm run build` 명령문을 사용해야 해당 스크립트가 실행된다.

```JSON
{
  "name": "01. NPM",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "build": "echo \"Here is custom script\""
  },
  "author": "",
  "license": "ISC"
}
```

`test` 명령어의 경우 기존 `npm` 명령어에서 제공하는 명령어기 때문에 `run` 명령어를 따로 안 붙이고 `npm test` 같은 형태로 바로 사용 가능하다.

`build` 명령어 뿐만 아니라 소스 코드에 대한 컨벤션을 검사하는 `lint` 명령어 또한 사용자 임의로 자주 추가하는 명령어다.

### 패키지 설치

#### CDN 이용

가장 간단한 방법은 컨텐츠 전송 네트워크(Contents Delivery Network, CDN) 방법을 활용하는 것이다. 이를 테면 HTML 소스 코드에 아래와 같이 `<script>` 태그를 추가하면 리액트라는 외부 라이브러리를 사용할 수 있게 된다.

```HTML
<script src="https://unpkg.com/react@16/umd/react.development.js"></script>
```

단, 이렇게 했을 때의 문제는 CDN 서버 자체에 문제가 발생하여 외부 라이브러리를 사용할 수 없게 될 때다. 다시 말해 개발 환경이 외부 서버에 의존하게 된다는 치명적인 단점이 존재한다.

#### 직접 다운로드

라이브러리 소스 코드를 직접 프로젝트 폴더에 다운로드 받을 수도 있다. 이렇게 할 경우 앞서 CDN의 단점이라 할 수 있는 외부 서버 의존성을 줄일 수 있지만 매번 수시로 해당 라이브러리의 업데이트 여부를 확인해야 하는 번거로움이 있다.

#### NPM 이용

NPM은 직접 다운로드하여 외부 서버의 의존성을 극복하는 것은 물론 버전에 따라 하위 호환성 여부를 확인하게 도와준다. 예를 들어 `npm install react` 명령문을 입력하면 [package.json](./package.json) 파일에 아래와 같이 `dependencies` 부분이 추가된다.

```JSON
{
  "name": "01. NPM",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "build": "echo \"Here is custom script\""
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "react": "^18.2.0"
  }
}
```

이를 통해 우리는 `react` 라이브러리를 직접 설치했으며 해당 버전이 `18.2.0`인 것을 확인할 수 있다.

#### 버전

이때 `^18.2.0`이라는 명시는 어떤 의미를 가질까?

먼저 버전을 엄격하게 관리한다고 생각해보자. 이를 테면 1.0 버전은 2.0 버전에서 전혀 사용할 수 없는 것이다. 그러면 매번 업데이트가 발생할 때마다 해당 라이브러리를 사용하는 사람은 라이브러리를 매번 전체 업데이트하여 수정할 수밖에 없다.

반대로 버전을 느슨하게 관리하면 어떨까? 1.0 버전을 사용하더라도 2.0 버전, 3.0 버전과 호환이 되는 것이다. 그러면 해당 라이브러리를 사용하는 사람은 평생 1.0 버저늘 사용할 위험성이 발생한다. 하나의 특정 버전에 갇히게 되는 것이다.

이러한 단점을 해결하기 위해 사용하는 버전 관리 방식이 바로 유의적 버전(Semantic Version)이다. 유의적 버전은 버전을 세 개로 나누어 관리하는 데 아래와 같다.

- 주 버전(Major Version): 기존 버전과 호환되지 않게 변경한 경우
- 부 버전(Minor Version): 기존 버전과 호환되면서 기능이 추가된 경우
- 수 버전(Patch Version): 기존 버전과 호환되면서 버그를 수정한 경우

설치한 리액트 라이브러리의 버전 `18.2.0`의 의미는 결국 기존 17 버전 등과는 호환되지 않는 18 버전이며 해당 버전 이후 몇 가지 기능을 추가하여 만들어진 `18.2.0` 버전인 것이다.

따라서 `18.x.x` 버전을 사용하는 모든 사람은 `18.2.0` 버전과 호환이 된다고 할 수 있다. 그리고 현재 버전에서 만약 몇 가지 버그가 수정될 경우 `18.2.1`과 같이 수 버전 부분이 증가하게 된다.

NPM은 이처럼 유의적 버전을 따르는 걸 가정해서 패키지 버전을 관리한다. 다시 말해 NPM을 통해 설치하는 모든 패키지는 대부분 해당 방식으로 버전 관리가 된다고 생각하면 된다.

#### 버전의 범위

그렇다면 이제 버전 앞에 붙은 `^` 문자는 무엇을 의미할까?

이는 캐럿(^)이라 부르며 정식 버전에서 부와 수 버전을 변경하는 걸 의미한다. 이를 테면 `^18.2.0` 버전은 `18.2.0` 버전부터 `^19.0.0` 버전 미만까지를 포함한다. 이때 중요한 건 캐럿 표기의 경우 정식 버전 미만인 `0.x` 버전에 대해서는 수 버전만 갱신한다. 다시 말해 `^0` 버전 표기는 `0.0.0` 버전부터 `0.1.0` 버전 미만을 의미한다.

이와 유사하지만 조금 다르게 작동하는 것으로 틸트(~) 표기가 있다. 틸트는 부 버전이 명시되어 있을 경우 수 버전만 변경하는 것을 의미한다. 이를 테면 `~18.2.1` 버전은 `18.2.1` 버전부터 `18.3.0` 버전 미만까지를 포함한다. 이때 만약 부 버전에 대한 표기가 별도로 존재하지 않을 경우 부 버전 갱신을 의미한다. 예를 들어 `~0` 버전 표기는 `0.0.0`  버전부터 `1.0.0` 버전 미만까지를 의미한다.

끝으로 버전의 범위에 대해서도 비교 연산을 활용하게 되는데 이를 테면 아래와 같다.

- `>18.2.0`
- `>=18.2.0`
- `<18.2.0`
- `<=18.2.0`

특정 버전 기준으로 초과, 이상, 미만, 이하 등을 표기하여 버전 관리를 직관적으로 할 수 있게 한다.

과거에는 NPM을 활용해 패키지를 설치할 경우 틸트 표기를 사용했지만 현재는 캐럿 표기를 이용하여 버전을 기록한다. 이는 `1.0.0` 버전 미만의 라이브러리 배포에 대해 발생하는 하위 호환성 문제를 보완하기 위함이다.

보통 사전 배포(Pre-release) 때는 패키지 버전이 수시로 수정될 수있는데 하위 호환성을 지키지 않고 배포하는 경우가 많다. 이때 `~0` 버전 표기와 같이 틸드 표기를 사용해 버전 범위를 표기하면 `0.0.0` 버전부터 `1.0.0` 버전 미만까지를 전부 사용하게 되기 때문에 하위 호환성이 지켜지지 않게 된다. 그러나 캐럿 표기를 사용하면 부와 수 버전의 변경을 의미하기 때문에 `^0.0` 버전 표기는 결국 `0.0.0` 버전부터 `0.1.0` 미만 버전을 의미하게 되어 하위 호환성을 유지할 수 있다.

#### package-lock 파일

외부 라이브러리를 설치하고 나면 [package-lock.json](./package-lock.json) 파일 및 `node_modules` 폴더가 추가적으로 생성된다.

[package-lock.json](./package-lock.json) 파일은 의존성 트리를 활용하여 라이브러리 버전에 대해 안정성을 보장한다. 예를 들어 여러 명의 개발자가 하나의 프로젝트를 함께 구현하는 경우 개발환경에서 라이브러리 버전이 모두 동일해야 실행에 있어 예상하지 못한 오류가 발생하지 않을 것이다. 이때 단순히 [package.json](./package.json) 파일만 사용하여 라이브러리를 설치할 경우 캐럿 표기로 인해 설치 당시보다 업데이트된 버전을 설치하게 될 때가 있다. 이럴 경우 간혹 업데이트된 버전에서 문제를 일으킬 수 있기 때문에 실제로 처음 설치한 특정 버전을 함께 공유해야 이러한 문제를 발생시키지 않는다. 이럴 때 [package-lock.json](./package-lock.json) 파일은 라이브러리를 설치한 시점의 버전을 관리하여 의존성 트리를 생성하기 때문에 이러한 문제를 보완할 수 있다.

보통 `node_modules` 폴더는 [.gitignore](./.gitignore) 파일을 사용해 별도로 업로드하지 않는다. 실제 라이브러리 코드들이기 때문에 그 양이 꽤 되기 때문이다.